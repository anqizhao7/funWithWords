# Fun With Words

In this project, I explore various methods for analyzing, generating and interacting with text programmatically. 

## Flesch Index

This method uses regular expressions to count the number of sentences, words, and syllables in a given text in order to calculate the Flesch index score. 

I estimate the number of syllables by using the following rules:
- Each contiguous sequence of one or more vowels is considered a syllable, with the exception of a lone "e" at the end of a word, which is not considered a syllable unless the word has no other syllables. 
- "Y" is considered a vowel.

Once all metrics are calculated, the score is given using the formula below. 
![Flesch Index Score Formula](/image/flesch_score.png)

The higher the score, the easier it should be to read the text. The two examples below show that an excerpt of War and Peace got a score of approximately 53 while an excerpt from Jack and the Beanstalk scored around 97.

_War and Peace_
![Flesch Index Score Hard](/image/flesch_index_hard.png)
_Jack and the Beanstalk_
![Flesch Index Score Easy](/image/flesch_index_easy.png)

## Markov Text 
The basic principle of a Markov process is that we should have a probability distribution on the next possible outcomes, based on the knowledge of our current state. 

For each unique word in the input text, I create a linked list of words that come after it, allowing for duplicates (this effectively gives duplicate words a higher probability). Punctuation is included in the previous word, so "say," is considered different from "say".

Then I can set any length and the algorithm will generate Markov text given the first word of the input text, by going through the linked list and randomly selecting any word by its index from the list. It will continue this process until the word count reaches the requested length. 

For short input text, simple and repetitive yields better results. In the example below, part of the lyrics from _"The Beatles - Hello, Goodbye"_ is used. In my trained word list, if the current state is the word "I", the next possible word will be generated from this list: 
```
["say,", "say,", "say,", "don't", "say,", "don't", "say,", "say,", "say,", "don't", "say,", "don't", "say,", "don't", "say,", "say,", "don't", "say,", "don't", "say,"]
```

I chose a length of 40 words and below is my new song.
![Markov Text](/image/markov.png)

Read about [Markov chains](https://en.wikipedia.org/wiki/Markov_chain) to learn more. 
 


## Spelling Suggestions
This method uses the concept of [trie](https://en.wikipedia.org/wiki/Trie) structures to highlight misspelled words and provide a list of suggestions.

First I create a trie from the list of words. Each node has a pointer to it's parent node, a hashmap of children nodes with the keys being letters, and a flag to indicate whether or not that node stops on a word.

When someone is typing, if what they have typed so far can not be found in the trie, it is highlighted in red.

The list of suggestions is generated by iterating through all possible mutations that are one insertion, substitution, or deletion away from the misspelled word. Words from this process that are found in the trie are used as suggestions (up to 10 words).  


![Suggestions](/image/spelling_suggestions.png)

## Auto Complete
This section uses the same trie structure as above to predict word completion. Firstly, receive a prefix typed in by the user and then use breadth first search to find all words in the trie that start with the given prefix. BFS will result in a completion list that is in ascending order by length.

Using a trie for this type of search is useful because as the prefix increases in length the total number of words in the subtrie decreases. 

![Auto Complete](/image/autocomplete.png)

## Distance Between Two Words
The distance between two words is taken as the number of insertions, substitutions and deletions required to transform word 1 into word 2. 

![Distance](/image/distance_cal.png)
I used breadth first search to find a path between word 1 and word 2. In each iteration, as words are popped from the queue, all words one mutation away (except those that have already been seen) are found and then added to the queue. This algorithm will return one of the paths of the lowest length, if any exist.

![Distance2](/image/distance_res.png)

***

Based on [Data structures: Measuring and Optimizing Performance](https://www.coursera.org/learn/data-structures-optimizing-performance)
